## 前言

### 来源

许多程序员从设计模式中学到了设计软件的灵感，或者找到了问题的解决方案。

设计模式并非是软件开发的专业术语。实际上，“模式”最早诞生于建筑学。

将这种“模式”观点应用于面向对象的软件设计中， 并且总结了23种常见的软件开发设计模式，录入《设计模式:可复用面向对象软件的基础》一书。

### 定义

定义：在面向对象软件设计过程中，针对特定问题的简洁而优雅的解决方案。

通俗来说，设计模式是在某种情景下对某个问题的一种解决方案。

再通俗一点说，设计模式就是给面向对象软件开发中的一些好的设计取个名字。

### 作用

帮助我们解决项目的问题以及优化

### 模式在不同语言之间的区别

《设计模式》最初讲的确实是静态类型语言中的设计模式，原书大部分代码由C++写成，但 设计模式实际上是解决某些问题的一种思想，与具体使用的语言无关。

设计思想是一样的，只不过在不同语言中，实现过程可能有点不同

### 适用性

从某些角度来看，设计模式确实有可能带来代码量的增加，或许也会把系统的逻辑搞得更复杂。
但软件开发的成本并非全部在开发阶段，
设计模式的作用是让人们写出可复用和可维护性高的程序。

所有设计模式的实现都遵循一条原则：找出程序中变化的地方，并将变化封装起来。

模式应该用在正确的地方，不要滥用

只有在我们深刻理解了模式的意图之后，再结合项目的实际场景才会知道

### 分辨模式的关键

在设计模式的学习中，我们常常疑问：有些模式的类图看起来一模一样，到底有什么区别？

实际上这种情况很普遍，许多模式的类图看起来差不多，只有放在具体的环境下才有意义。

辨别模式的关键是这个模式出现的场景以及为我们解决了什么问题

## 设计模式

### 1. 单例模式

定义：保证一个类仅有一个实例，并提供一个访问它的访问点。

有一些对象我们往往只需要一个，比如线程池，全局缓存，浏览器中的window对象等。

试想场景：
1. 我们在点击登录按钮时，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论点击多少次，都只会创建一次，那么这个登录浮窗适合用单例模式来创建
2. 文档管理器
3. 设备管理器
4. 命名空间
5. 管理功能模块

实现思想：用一个变量来标志当前是否已经为某个类创建过了对象，如果是，则在下次获取该类的实例时，直接返回之前创建好的对象

保持对象的唯一性、自己内部实现，不关心外部对它的使用

解决问题：一个全局使用的对象频繁地去创建和销毁

优点：在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例
     避免对资源的多重占用（比如写文件操作）

缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

#### 实现单例模式

```js
var Singleton = function(name) {
  this.name = name;
  this.instance = null;
}
Singleton.prototype.getName = functon() {
  alert(this.name);
}
Singleton.getInstance = function(name) {
  if (!this.instance) {
    this.instance = new Singleton(name);
  }
  return this.instance;
};

var a = Singleton.getInstance('a1');
var b = Singleton.getInstance('b1');

a === b;  // true
```

#### 透明的单例模式

实现一个“透明”的单例类，用户从这个类中创建对象的时候，可以像使用其他任何普通类一样。

### 2. 发布-订阅模式（观察者模式）

它定义对象间的一种一对多的依赖关系，当一个对象的状 态发生改变时，所有依赖于它的对象都将得到通知。

在 JavaScript 开发中，我们一般用事件模型 来替代传统的发布—订阅模式。

#### 2.1 现实场景

现实场景：
比如，客户向售楼处打电话询问开盘时间，工作人员每天都会接到n个相同的电话，会很烦。但如果工作人员把客户的电话收集起来，到了开盘时间，给这些客户发条短信，通知他们开盘了。

上面的例子中，发送短信通知就是一个典型的发布—订阅模式，小明、小红等购买者都是订阅者，他们订阅了房子开售的消息。售楼处作为发布者，会在合适的时候遍历花名册上的电话 号码，依次给购房者发布消息。

#### 2.2 作用

优点：
1. 购房者不用再天天给售楼处打电话咨询开售时间，在`合适的时间点`，售楼处作为发布者 会通知这些消息订阅者

2. `购房者和售楼处之间不再强耦合在一起`，当有新的购房者出现时，他只需把手机号码留在售楼处，售楼处不关心购房者的任何情况，购房者也不用关心售楼处其他的情况，只要售楼处记得发短信这件事情就可以了

第一点说明发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。 比如，我们可以订阅 ajax 请求的 error、succ 等事件。 或者如果想在动画的每一帧完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中 使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。

第二点说明发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改;同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。

#### 2.3 DOM事件

实际上，只要我们曾经在 DOM 节点上面绑定过事件函数，那我们就曾经使用过发布—订阅模式。
比如我们常常使用的 onClick 点击事件

```js
document.body.addEventListener( 'click', function(){ alert(2);
}, false );
document.body.click();

```

#### 2.4 自定义事件

如何一步步实现发布—订阅模式：

1. 首先要指定好谁充当发布者(比如售楼处);
2. 然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者(售楼处的花名册); 
3. 最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数(遍历花名册，挨个发短信)。

另外，我们还可以往回调函数里填入一些参数，订阅者可以接收这些参数。

```js
var salesOffices = {}; // 定义售楼处
salesOffices.clientList = []; // 缓存列表，存放订阅者的回调函数
salesOffices.listen = function( fn ){ // 增加订阅者 
  this.clientList.push( fn ); // 订阅的消息添加进缓存列表
};
salesOffices.trigger = function(){ // 发布消息 
  for( var i = 0, fn; fn = this.clientList[ i++ ];) {
    fn.apply( this, arguments );
  } 
};

// 小明订阅消息
salesOffices.listen( function( price, squareMeter) {
  console.log( '价格= ' + price );
  console.log( 'squareMeter= ' + squareMeter );
});

salesOffices.trigger( 2000000, 88 ); // 输出:200 万，88 平方米
```

至此，我们已经实现了一个最简单的发布—订阅模式，但这里还存在一些问题。我们看到订 阅者接收到了发布者发布的每个消息，虽然小明只想买 88 平方米的房子，但是发布者把 110 平 方米的信息也推送给了小明，这对小明来说是不必要的困扰。所以我们有必要增加一个标示 key， 让订阅者只订阅自己感兴趣的消息。
改写后的代码如下:

```js
var salesOffices = {}; // 定义售楼处
salesOffices.clientList = {}; // 缓存列表，存放订阅者的回调函数 

salesOffices.listen = function( key, fn ){
  if ( !this.clientList[ key ] ) {  // 如果还没有订阅过此类消息，给该类消息创建一个缓存列表
    this.clientList[ key ] = [];
  } 
  this.clientList[ key ].push( fn );  // 订阅的消息添加进消息缓存列表
};

salesOffices.trigger = function(){ // 发布消息
  var key = Array.prototype.shift.call( arguments ), // 取出消息类型
  fns = this.clientList[ key ]; // 取出该消息对应的回调函数集合
  if ( !fns || fns.length === 0 ){ return false;} // 如果没有订阅该消息，则返回

  for( var i = 0, fn; fn = fns[ i++ ]; ){
    fn.apply( this, arguments ); // (2) // arguments 是发布消息时附送的参数
  } 
};

// 小明订阅 88 平方米房子的消息
salesOffices.listen( 'squareMeter88', function( price ){ 
  console.log( '价格= ' + price ); // 输出: 2000000
});
// 小红订阅 110 平方米房子的消息
salesOffices.listen( 'squareMeter110', function( price ){ 
  console.log( '价格= ' + price ); // 输出: 3000000
});
salesOffices.trigger( 'squareMeter88', 2000000 ); // 发布 88 平方米房子的价格
salesOffices.trigger( 'squareMeter110', 3000000 ); // 发布 110 平方米房子的价格
```

#### 2.5 发布订阅模式的通用实现

将发布订阅的功能提取出来，放在一个单独的对象中，再定义install和remove函数来给对象动态安装发布订阅的功能

#### 2.6 真实例子-网站登录

比如某商场网站，有headre头部，nav导航，消息列表，购物车等模块，

这几个模块的渲染有一个共同的前提条件，就是必须先用 ajax 异步请求获取用户的登录信息。 

这是很正常的，比如用户的名字和头像要显示在 header 模块里，而这两个字段都来自用户登录后 返回的信息 

至于ajax请求什么时候返回用户信息，我们可以用回调函数来解决

但如果和其他模块产生了耦合，比如：
```js
login.succ(function(data){ 
  header.setAvatar( data.avatar); // 设置 header 模块的头像
  nav.setAvatar( data.avatar ); // 设置导航模块的头像
  message.refresh(); // 刷新消息列表
  cart.refresh(); // 刷新购物车列表
});
```
假如之后再有一个地址模块等，还需要再这里进行修改。本来这种写法就不合适，自己的模块应该在自己模块去做。

所以可以实现订阅发布模式来改写代码
```js
$.ajax( 'http:// xxx.com?login', function(data){ // 登录成功 
  login.trigger( 'loginSucc', data); // 发布登录成功的消息
});
```

各个模块来监听登录成功的消息：
```js
var header = (function(){ // header 模块 
  login.listen( 'loginSucc', function( data){
    header.setAvatar( data.avatar );
  });
 return {
  setAvatar: function( data ){
    console.log( '设置 header 模块的头像' );
  } 
}
})();
```

#### 2.7 全局的发布订阅对象

回想上面的例子，我们给售楼处对象和登录对象都添加了订阅和发布的功能，还有两个小问题：
1.我们给每个发布者都添加了listen和trigger方法，以及缓存列表，其实是资源浪费
2.小明和售楼处对象还是存在一定的耦合性，至少需要知道售楼处对象的名字

在程序中，我们可以用一个全局的Event对象来实现发布订阅

#### 2.8 模块间通信

比如现在有两个模块，A模块里面有按钮，每次点击按钮之后，b模块里的div中会显示按钮的点击次数

实现这个功能，有很多方法，比如Redux，Context，我们也可以用发布订阅模式

如果用太多全局的发布订阅模式，模块之间的联系就被隐藏了背后，也会带来一些麻烦

#### 2.9 小结

发布—订阅模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。
它的应用非常 广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。
发布—订阅模式还可 以用来帮助实现一些别的设计模式，比如中介者模式。
从架构上来看，无论是 MVC 还是 MVVM， 都少不了发布—订阅模式的参与，而且 JavaScript 本身也是一门基于事件驱动的语言。

当然，发布—订阅模式也不是完全没有缺点。
创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。
另外，发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联 系也将被深埋在背后，会导致程序难以跟踪维护和理解。
特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个bug不是件轻松的事情。

什么时候应该用它呢？

当一个对象的改变需要同时改变其他对象的时候，而且它不知道具体有什么对象有待改变时，应该考虑使用观察者模式

我感觉当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，使用观察者模式可以将这两个封装在独立的对象中，使他们各自独立地改变和复用。

观察者模式所做的工作其实就是在解耦合

#### 2.10 观察者和发布订阅模式

观察者模式： 观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。

发布订阅模式： 订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Topic），当发布者（Publisher）发布该事件（Publish topic）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。

#### 2.11 观察者模式是不是发布订阅模式

网上关于这个问题的回答，出现了两极分化，有认为发布订阅模式就是观察者模式的，也有认为观察者模式和发布订阅模式是真不一样的。

其实我不知道发布订阅模式是不是观察者模式，就像我不知道辨别模式的关键是设计意图还是设计结构（理念），虽然《JavaScript设计模式与开发实践》一书中说了分辨模式的关键是意图而不是结构。

如果以结构来分辨模式，发布订阅模式相比观察者模式多了一个中间件订阅器，所以发布订阅模式是不同于观察者模式的；
如果以意图来分辨模式，他们都是实现了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新，那么他们就是同一种模式，发布订阅模式是在观察者模式的基础上做的优化升级。

不过，不管他们是不是同一个设计模式，他们的实现方式确实有差别，我们在使用的时候应该根据场景来判断选择哪个。

#### 2.12 问题

在 JavaScript 中，我们无需去选择使用推模型还是拉模型。
推模型是指在事件发生时， 发布者一次性把所有更改的状态和数据都推送给订阅者。
拉模型不同的地方是，发布者仅仅通知 订阅者事件已经发生了，此外发布者要提供一些公开的接口供订阅者来主动拉取数据。
拉模型的 好处是可以让订阅者“按需获取”，但同时有可能让发布者变成一个“门户大开”的对象，同时 增加了代码量和复杂度。
刚好在 JavaScript 中，arguments 可以很方便地表示参数列表，所以我们一般都会选择推模型， 使用 Function.prototype.apply 方法把所有参数都推送给订阅者。

### 3 代理模式

代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。

代理模式包括许多小分类，在 JavaScript 开发中最常用的是虚拟代理和缓存代理。虽然代理 模式非常有用，但我们在编写业务代码的时候，往往不需要去预先猜测是否需要使用代理模式。 当真正发现不方便直接访问某个对象的时候，再编写代理也不迟。

